anycore-riscv
===========================================================================


1. [Quickstart](#quickstart)
2. [Tour of The Sources](#tour)
3. [Build the Tools](#build-tools)
4. [Run RTL Simulations](#rtl-sim)
5. [Run Functional Simulator](#functional-sim)
6. [Commit Changes in Submodules](#commit-submodules)

# <a name="quickstart"></a>Quickstart

Check the version your git by using:

	% git --version

#####If your git version is above 1.7.9

	% git clone --recursive https://github.ncsu.edu/AnyCore/anycore-riscv.git

#####If you are using git version before 1.7.9, you must specify your username for  https://github.ncsu.edu

######If using C-Shell:

	% set GIT_USER_NAME=<username>    
	% git clone https://`echo $GIT_USER_NAME`@github.ncsu.edu/AnyCore/anycore-riscv.git
	% cd anycore-riscv/
	% sed -i -- 's/github\.ncsu/'`echo $GIT_USER_NAME`'@github\.ncsu/g' .gitmodules 
	% git submodule update --init --recursive
	
######If using Bash:	

	$ export GIT_USER_NAME=<username>    
	$ git clone https://`echo $GIT_USER_NAME`@github.ncsu.edu/AnyCore/anycore-riscv.git
	$ cd anycore-riscv/
	$ sed -i -- 's/github\.ncsu/'`echo $GIT_USER_NAME`'@github\.ncsu/g' .gitmodules 
	$ git submodule update --init --recursive


#####WARNING:
If you just want to use the codebase to run tests, you are all set to move on to [Build The Tools.]#build-tools). However, if you think that you might need to modify code in any of the submodules and want to commit them back to upstream repo, read the section on [Committing Submodules](#commit-submodules) very carefully. You have been warned! Unless you have a very good reason to checkout riscv-pk, riscv-fesvr, and riscv-isa-sim, do not checkout these repos. The Anycore toolset is tied to a specific version of these repos and checking them out will mess up the dependncy and the toolset will either fail to build or run correctly.

# <a name="build-tools"></a>Build the Tools
The tools need GCC version 4.9.2 or above to be built correctly. If you are using the latest version of Ubuntu or Fedora, you are good to go. If you are using RHEL-6 or below, you must  use the precompiled version of gcc-4.9.2 provided by RHEL devtoolset-3. The build scripts automatically use devtoolset-3. If you want to use a different GCC you must set the appropriate environment variables in build-all.sh . Things that need to be done to use a different toolchain is in the notes.

<!--
The "spike" architectural simulator is built and installed in anycore-riscv/install_spike. You should add this location (even if the directory does not exist yet) to your path (in ~.mycshrc or ~/.bashrc) since building rest of the toolset requires spike to be searched and found in the path. If you do not know how to add a new path to ~/.mycshrc or ~/.bashrc , read http://www.cyberciti.biz/faq/unix-linux-adding-path/ for a nice tutorial. You should source the new ~/.mycshrc OR ~/.bashrc for the changes to take effect.

After adding "install_spike" to the path, execute the folloing commands:
-->

Now, execute the folloing commands:

	% cd anycore-riscv
	% vi build.common   #Change the number of jobs in this filebased on your build machine
	% ./build-all.sh
	
This will build all the necessary tools and install them in anycore-riscv/install. You should add this locations to your path (in ~.mycshrc or ~/.bashrc) so that it is easy to use the tools.

######NOTE:
If using the gcc-4.9.2 installed on your system or a custom gcc, edit build-all.ch and modify GCC_PATH and GCC_SUFFIX variables to match your GCC's path and suffix. For installed GCCs, the path will probably be /usr/bin and suffix will be "" (blank).

# <a name="tour"></a>Tour of the Sources

If we are starting from a relatively fresh install of
GNU/Linux, it will be necessary to install the RISC-V toolchain. The toolchain
consists of the following components:

*   `riscv-fesvr`, a "front-end" server that
services calls between the host and target processors on the Host-Target
InterFace (HTIF) (it also provides a virtualized console and disk device)
*   `riscv-isa-sim`, the ISA simulator and
"golden standard" of execution
*   `riscv-pk`, a proxy kernel that services
system calls generated by code built and linked with the RISC-V Newlib port
(this does not apply to Linux, as _it_ handles the system calls)
*   `riscv-tests`, a set of assembly tests
and benchmarks
*   `anycore-riscv-src`, The RTL for AnyCore-RISCV
*   `anycore-tests`, a set of assembly tests
*   `riscv-dpi`, DPI code needed for RTL simualtions and checking committed instruuctions. 
and benchmarks along with simulation infrastructure for 
running RTL test.

# <a name="rtl-sim"></a>Run RTL Simulations

The simulations are run in a separate scratch directory to prevent it from using up AFS space. The path to this scratch space should be specified in the Makefile or overridden from the command line as follows (`NOTE`: You must change the SCRATCH_SPACE variable in the Makefile to point to a valid location):

    % make rtl SPEC_SRC_DIR="<Path to SPEC directory>" SCRATCH_SPACE="<Path to scratch space>"

Simulation runs are done in SCRATCH_SPACE/anycore_micro_test and appropriate test directories are created in this hierarchy.

`NOTE`: You must change the VERILOG_SRC pnd the RISC_INSTALL_DIR  in rtl.mk to point to the appropriate paths.

# <a name="functional-sim"></a>Run Functional Simulator

Write a short C program and name it hello.c.  Then, compile it into a RISC-V. If you are at NCSU, the comross compiler can be added using 'add risv'. Otherwise, you need to compile your own cross compiler. by following [these instructions] (https://github.com/riscv/anycore-riscv/blob/master/README.md)
ELF binary named hello:

    % add riscv
    % riscv64-unknown-elf-gcc -o hello hello.c

Now you can simulate the program atop the proxy kernel:

    % spike pk -c hello

For more information, visit https://github.com/sherry151/riscv-isa-sim/blob/master/README.md

# <a name="commit-submodules"></a>Commit Changes in Submodules

When you clone a repo and recursively init all its submodules, each submodule remains
in a state called "Detached HEAD State". What this basically means is that the submodule
repo is "branchless". It does not track any local or remote branches. In this state, you 
can use everything in the repo, play around, modify and even commit your changes. What you
can't do however is push your commits to a remote as your HEAD is not tracking any branch.
There are at least two simple ways to get around this issue:

## Checkout a branch and then start modifying
	% cd <submodule_directory>
	% git checkout <branch_you_want_to_use>
	...
	..
	Make all modifications
	..
	% git add <Stuff you want to commit>
	% git commit -m"Made bunch of modifications"
	% git push
	% cd <parent repo>
	% git status        ## This will show you changes in the submodule
	% git add <submodule_directory>
	% git commit -m"Modified a submodule"
	% git push

## If you didn't checkout before modifying, create a new branch with your latest commit and merge

	% cd <submodule_directory>
	...
	..
	Make all modifications
	..
	% git add <Stuff you want to commit>
	% git commit -m"Made bunch of modifications"
	% git branch temp_commit_branch <##Commit hash>
	% git checkout <branch_you_want_to_actually_commit_to>
	% git merge temp_commit_branch <branch_you_want_to_actually_commit_to>
	% git push
	% cd <parent repo>
	% git status        ## This will show you changes in the submodule
	% git add <submodule_directory>
	% git commit -m"Modified a submodule"
	% git push


[Return to top.](#quickstart)

## <a name="references"></a> References
* https://github.com/riscv/anycore-riscv/blob/master/README.md
* Waterman, A., Lee, Y., Patterson, D., and Asanovic, K,. "The RISC-V Instruction Set Manual," vol. II, [http://inst.eecs.berkeley.edu/~cs152/sp12/handouts/riscv-supervisor.pdf](http://inst.eecs.berkeley.edu/~cs152/sp12/handouts/riscv-supervisor.pdf), 2012.

